9. threading.Event() can be used to synchronize threads. set() sets the event to be true; is_set() returns true if set() is called; clear() resets the event to be false; wait() blocks the current if the event is not set(); wait(timeout) blocks in timeout period
8. To exchange information between threads, we should never use immutables, as they do not reflect the changes made by one thread in other threads
7. a = 9;
   def f():
	# the global immutable variable can only be referenced, not assigned, except mutables
	print (a) # throw "referenced before assignment" error
	a += 1
   
6. set attributes of an object, e.g. setattr(function_obj, "__doc__", "some docstring")
5. To be a closure, make sure nested function, reutrn function object, and at least one variable in the outer function is used inside. closure_obj.__closure__[0].cell_contents; [i] depends on the number of varibles enclosed
4. closure returns a different object whenever called
3. a=[2]; b = a[:] -> id(a) != id(b) -> deep copy
2. swap two values: a, b = b, a
1. "with CONTEXTMANAGER() as cm:" -> inside CONTEXTMANAGER(), __enter__(self), __exit__(self, excp_type, excp_value, excp_traceback) need to be implemented; __enter__() does not need to return anything
