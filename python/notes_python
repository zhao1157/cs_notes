19. threading.Condition.wait_for(predicate, timeout) limits the maximum time to wait as timeout
18. threading.Barrier().wait(timeout) will throw a BrokenBarrierError if timeout is reached
17. threading.Event().wait(timeout) returns True if set() is called while it's waiting, False if set() is not called before timint out
16. threading.Condition() .notify() has to be for an already acquired lock, and only notify the threads that are already waiting on the lock; .wait() releases the lock and wait; supports with statement;
15. threading.Lock() supports context manager "with" statement
14. threading.RLock() not only ensures that only one thread access the critical block at a time, but also enables reacquiring the the same multiple times without requiring the outer lock released; the number of acquire() and release() has to be the same, otherwise it won't release the lock, so other threads won't be able to acquire the lock, thus deadlocking.
13. threading.Lock() ensures only one thread has the lock at a time, lock.acquire(); some_critical_code_block; lock.release(); when more than one threads are waiting, the subsequent thread acquires the lock after the previous one releases it
12. To exchange info through immutables, we need to make the immutables global in the scope where its value is changed.
11. To modify a global immutable in a function, we can in the function declare it as a global in order to avoid referenced before assignment error
10. threading.Barrier() blocks a set of threads until a certain number of them called wait(); it can be used recursively, i.e. as long as parties==n_waiting, all waiting threads are unblocked, and wait() can be reused again to form another blocking
9. threading.Event() can be used to synchronize threads. set() sets the event to be true; is_set() returns true if set() is called; clear() resets the event to be false; wait() blocks the current if the event is not set(); wait(timeout) blocks in timeout period
8. (ERROR, WRONG) To exchange information between threads, we should never use immutables, as they do not reflect the changes made by one thread in other threads
7. a = 9;
   def f():
	# the global immutable variable can only be referenced, not assigned, except mutables
	print (a) # throw "referenced before assignment" error
	a += 1
   
6. set attributes of an object, e.g. setattr(function_obj, "__doc__", "some docstring")
5. To be a closure, make sure nested function, reutrn function object, and at least one variable in the outer function is used inside. closure_obj.__closure__[0].cell_contents; [i] depends on the number of varibles enclosed
4. closure returns a different object whenever called
3. a=[2]; b = a[:] -> id(a) != id(b) -> deep copy
2. swap two values: a, b = b, a
1. "with CONTEXTMANAGER() as cm:" -> inside CONTEXTMANAGER(), __enter__(self), __exit__(self, excp_type, excp_value, excp_traceback) need to be implemented; __enter__() does not need to return anything
