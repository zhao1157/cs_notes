80. Functor is just like the call() function in a python class
79. Functor: () operator overloading; P p; p(2); -> it is calling () operator
78. "P p;" -> calling constructor; "P p = p0;" -> not calling constructor nor assignment operator overloading; "P p; p = p0;" -> calling constructor first to create an object, then assignment operator overloading to modify some of its data members
77. If a class has a pointer member, make sure it's initialized, otherwise segmentation fault when copied to another object;
76. Assignment operator overloading: Person & operator = (const Person & p); if (this != & p) do sth; return *this;
75. In a thread, when passing by reference, use std::ref(variable), by default it is by value
74. Just like smart pointers, we can wrap std::thread inside a class and join or detach it inside the destructor.
73. std::thread is not copiable, but movable
72. we can spawn another child thread inside a child thread
71. class P{..}; P p; p = P(2); P p()-> not corrected as it's treated as a function declaration; p = P()
70. if the child process needs more time than the main thread and the child thread is detached from the main one, then the child thread will run to the end and deallocates resources allocated.
69. std::thread my_thread; my_thread.join() -> the main thread will wait for the child thread to finish; my_thread.detach() -> the child thread is separated from the main thread, and it will execute independently.
68. std::thread my_threads[3]; for (auto & thread : my_threads); note: without &, error
67. <unistd.h>, there is a feature, which is sleep(2), just like the command in linux terminal
66. std::this_thread::sleep_for(std::chrono::seconds(2)), or microseconds(2000000), or milliseconds(2000), nanoseconds(2000000000): put this thread in sleep for a mount of time
65. without specifying task_thread.join() or task_thread.detach(), the program will abort.
64. "->" overloading, it returns just the pointer itself
63. *ptr returns a reference(has a memory location), it is a lvalue, thus can be assigned to a rvalue
62. If a function returns a reference, we can assign a value to that function.
61. Smart pointers are a part of the STL library, so we can practice implementing some of their features by template class. Like automatically releasing memory when out of scope, and deferenced just like regular pointer.
60. struct and class can both be templated
59. we can control the instances of a template class to be another class's friends.
58. If T is a cutomized class type, "friend T" works to set T as a friend class
57. For a template class Person, Person<xx> is an actual class, while Person is just a blueprint or template, not an actual class
56. Within a template class there is a friend class, thus the friend class has to be a template class. Inside the class, declare the friend class: "template<typename TT> friend class Friend;". note: the template parameters have to match, otherwise not friends.
55. Virtual polymorphism works in the case of pointer, not in reference case
54. dynamic_cast<Person &> (*ptr), or dynamic_cast<Person *> (ptr)
53. class templates can be inherited, and only difference is to specify the template parameters when using it.
52. when calling static functions/data in a template class, we do not have to specify the template parameters, like Family<T, N>::num_of_families; if outside of class, we have to specify the template parameters. The static members are not shared in different template parameters, and are shared if the template parameters are the same
51. class template --> member function defined outside of the class: template<typename T, int N> T* Family<T, N> Get(){...}
50. templates are a type of polymorphism, happening at compile time. Parametric polymorphism
49. templates can work for a mix of typename and variable, template<typename T, int N> ...
48. templates can also work for non-typename variables like template <int N> void SetArr(){...}
47. templates can also be overloaded with the same function name
46. Function template syntax: template<typename T, typename U, ...> U Get(T a){...}; calling by Get<int, double> (2); ...
45. the size of a class is the sum of all member data, not member functions; if no member data preset, it is just 1
44. pointer always has the same size, no matter what type it is, even the cutomer-defined classes
43. [] overloading for class
42. operator overloading ++: void operator ++() --> prefix; void operator ++(int) --> postfix, note it must be int in ()
41. operator overloading function is just like regular functions, but with operator before the function name
40. typeid(variable_name).name() returns the type of variable_name; do some comparison == or !=
39. static polymorphism: function overloading and operator overloading
38. void f(int i); void f(const int i); not allowed as it redefines the function
37. void f(); void f(int i = 0); ambiguous
36. Function overloading can not be  distinguished by the return type
35. int * const ptr = &a; const pointer has to be initialized, and ptr can not be changed but *ptr = 34 is valid to modify the value of the memory address
34. If static member is public, in main function we can access class::static_member or class::static_function
33. const member function in a class can not modify the regular member data, but can modify static member data, and it can not call non-const member function, but can call whatever non-member functions.
32. In c++, encapsulation includes 1) the functions 2) the classes which have different access types (private, protected and public). The different part coordinate with each other through APIs without knowing the details of the implementation
31. Static/dynamic_cast<>(): for non-virtual functions use the ones in the casted-type, otherwise the ones in the actual object; dynamic_cast only works if the casted type is in the upper inheritence level of the actual object and virtual class
30. Dynamic_cast can only convert derived class object pointer/reference to one of the parents' type pointer
29. Use dynamic_cast to filter out the instances of the class type we are interested in.
28. ptr_b = new derive; ptr_d = static_cast<derive *> (ptr_b) or ptr_d = dynamic_cast<derive*> (ptr_b); ptr_d -> d_only_func()
27. dynamic_cast<derive*> (base ptr), where base ptr is a base-type pointer pointing a derived class; the base type has be virtual; if successful, a pointer or reference is created, otherwise null or 0; static_cast<base*>(derive pointer);
26. In virtual base class situation, the virtual functions in the derived class can be overriden by the ones in the base class.
25. (static_cast can NOT be used between two non-related classes, while the c-type casting can) static_cast<Base> (d); static_cast<Base *> (&d); static_cast<Base *> (ptr_d);
24. static_cast<int> (a); static_cast<double> (b);
23. Just like in class, there are also member functions in struct, and types might be virtual, override, final, static. The same inheritence rules as in class. But the default are the opposite of class.
22. virtual/override/final are only allowed within the class, not outside of it.
21. In a derived class, when overriding a virtual function in the base class, it is a good practice to put "override" behind the defition, for readabilty for both readers and compilers.
20. Static variables and functions are also inheritable, nothing different from the normal members, except the static feature
19. Without static keyword before the function name, the members can only be accessed by its instance, not by class itself.
18. Why static variable in a class has to be initialized outside of class? The reason is if not, its value will be reset every time a new instance of the class is created.
17 The static variables in a class are attributes of class itself, only one copy no matter how many instances of the class are created, its memory is inside the class, not inside the object memory. It can be accessible by class itself through operator "::", not ".", and by instances through ".". All member functions can access the static variabls, while static member function can only access the static variables. The static variable has to be initialized outside of the class definition.
16. The static variable inside a function will keep its value updated.
15. virtual keyword makes the binding of function body happen at runtime (late/dynamic binding), without virtual keyword, the binding happens at comiling time. Derived class is casted to base class pointer, the pointer will point to the virtual function in the derived class, not in the base class. For the non-virtual function, pointer points to the functions in the base class.
14. Only the newly-defined members of the friend class can be the context where the private/protected part of the class are accessible.
13. In friend class, the members from the base class are accessible
12. The member functions of the base class will be hidden in the derived class if functions with the same name are redefined in the derived class.
11. protected inheritence: the protected and public members of the base class are grouped to the protected part of the derived class, again the private members of the base class are not inherited
10. friend class in the base class is not inherited to the derived class
9. public inheritence: protected members of the base class go to the protected part of the derived class and the public members of the base class go to the public part of the derived class, however the private part of the base class is not inherited to the derived class and the new defined memmbers of the derived class can not access base private members.
8. public/protected/private inheritence: the private members of the base class can not be inherited, and the member functions of the new defined class can not access the private members of the base class, but the original member functions inherited from the base class can still access the private members
7. final: make the classes inheriting from this class without modifying it.
6. override: there is no actual functionality of override and it is just a tag saying the function is overridden, without this tag it still overrides the virtual function in the base class. It is a good practice to put this tag after the declaration, indicating this function is virtual in base class, and it is overridden in this class.
5. abstract class: pure virtual functions make the class abstract, which can not be instantiated.
4. virtual: defines a virtual function, which will be overriden in the derived class, when casted to the base class, the virtual functions will be overridden by those in the derived class, while other non-virtual functions will still be the ones in the original base class
3. If the derived class has functions which share names with those in the base class, the derived class will only have those redefined in the derived class, hiding all those in the base class
2. Inside the friend function/class, the instance of the class of interest can access the private and protected members, i.e. all members as if it was inside the class of interest.
1. In class inheritence, the derived class can inherit from protected members of the base class, so the derived class can directly access them, but can not access the private members of the base class
