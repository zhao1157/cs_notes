28. ptr_b = new derive; ptr_d = static_cast<derive *> (ptr_b) or ptr_d = dynamic_cast<derive*> (ptr_b); ptr_d -> d_only_func()
27. dynamic_cast<derive*> (base ptr), where base ptr is a base-type pointer pointing a derived class; the base type has be virtual; if successful, a pointer or reference is created, otherwise null or 0; static_cast<base*>(derive pointer);
26. In virtual base class situation, the virtual functions in the derived class can be overriden by the ones in the base class.
25. (static_cast can NOT be used between two non-related classes, while the c-type casting can) static_cast<Base> (d); static_cast<Base *> (&d); static_cast<Base *> (ptr_d);
24. static_cast<int> (a); static_cast<double> (b);
23. Just like in class, there are also member functions in struct, and types might be virtual, override, final, static. The same inheritence rules as in class. But the default are the opposite of class.
22. virtual/override/final are only allowed within the class, not outside of it.
21. In a derived class, when overriding a virtual function in the base class, it is a good practice to put "override" behind the defition, for readabilty for both readers and compilers.
20. Static variables and functions are also inheritable, nothing different from the normal members, except the static feature
19. Without static keyword before the function name, the members can only be accessed by its instance, not by class itself.
18. Why static variable in a class has to be initialized outside of class? The reason is if not, its value will be reset every time a new instance of the class is created.
17 The static variables in a class are attributes of class itself, only one copy no matter how many instances of the class are created, its memory is inside the class, not inside the object memory. It can be accessible by class itself through operator "::", not ".", and by instances through ".". All member functions can access the static variabls, while static member function can only access the static variables. The static variable has to be initialized outside of the class definition.
16. The static variable inside a function will keep its value updated.
15. virtual keyword makes the binding of function body happen at runtime (late/dynamic binding), without virtual keyword, the binding happens at comiling time. Derived class is casted to base class pointer, the pointer will point to the virtual function in the derived class, not in the base class. For the non-virtual function, pointer points to the functions in the base class.
14. Only the newly-defined members of the friend class can be the context where the private/protected part of the class are accessible.
13. In friend class, the members from the base class are accessible
12. The member functions of the base class will be hidden in the derived class if functions with the same name are redefined in the derived class.
11. protected inheritence: the protected and public members of the base class are grouped to the protected part of the derived class, again the private members of the base class are not inherited
10. friend class in the base class is not inherited to the derived class
9. public inheritence: protected members of the base class go to the protected part of the derived class and the public members of the base class go to the public part of the derived class, however the private part of the base class is not inherited to the derived class and the new defined memmbers of the derived class can not access base private members.
8. public/protected/private inheritence: the private members of the base class can not be inherited, and the member functions of the new defined class can not access the private members of the base class, but the original member functions inherited from the base class can still access the private members
7. final: make the classes inheriting from this class without modifying it.
6. override: there is no actual functionality of override and it is just a tag saying the function is overridden, without this tag it still overrides the virtual function in the base class. It is a good practice to put this tag after the declaration, indicating this function is virtual in base class, and it is overridden in this class.
5. abstract class: pure virtual functions make the class abstract, which can not be instantiated.
4. virtual: defines a virtual function, which will be overriden in the derived class, when casted to the base class, the virtual functions will be overridden by those in the derived class, while other non-virtual functions will still be the ones in the original base class
3. If the derived class has functions which share names with those in the base class, the derived class will only have those redefined in the derived class, hiding all those in the base class
2. Inside the friend function/class, the instance of the class of interest can access the private and protected members, i.e. all members as if it was inside the class of interest.
1. In class inheritence, the derived class can inherit from protected members of the base class, so the derived class can directly access them, but can not access the private members of the base class
